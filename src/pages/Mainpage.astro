<script>
  import Konva from "konva";

  const containerEl = document.getElementById("container");

  // Initialize stage and layer
  var stage = new Konva.Stage({
    container: "container",
    width: containerEl.clientWidth,
    height: containerEl.clientHeight,
  });

  var deckLayer = new Konva.Layer();
  stage.add(deckLayer);

  var boardX = containerEl.clientWidth * 0.1; // Starting X coordinate
  var boardY = containerEl.clientHeight * 0.2; // Starting Y coordinate
  var currentAngle = 0; // Starting angle in degrees

  // sidebar x
  var sidebarX = containerEl.clientWidth * 0.8;

  var line = new Konva.Line({
    points: [boardX, boardY],
    stroke: "black",
    strokeWidth: 8,
    strokeEnabled: true,
    fillEnabled: true,
    shadowColor: "red",
        lineCap: 'round',
        lineJoin: 'round',
        /*
         * line segments with a length of 29px with a gap
         * of 20px followed by a line segment of 0.001px (a dot)
         * followed by a gap of 20px
         */
        dash: [29, 20, 0.001, 20],
  });
  deckLayer.add(line);

  const createCircle = (x, y) => {

    const rect = new Konva.Rect({
      x: 0,
      y: 0,
      width: 20,
      height: 20,
      fill: 'black',
      offsetX: 10,
      offsetY: 10,
    })
    const circle = new Konva.Circle({
      x: 0,
      y: 0,
      radius: 20,
      stroke: 'red',
      fill: "red",
    });
    const group = new Konva.Group({
      x: x,
      y: y,
      draggable: true,
    })
    group.add(circle, rect)


    var startCopyEnabled = false;
    var endCopyEnabled = false;

    group.on("dragstart", (e) => {
      const target = e.target;
      const position = target.getAbsolutePosition();

      const targetX = position.x;
      const targetY = position.y;

      // dont crate a copy if its not the sidebar circle
      if (targetX == sidebarX && targetY == boardY) {
        startCopyEnabled = true;
      }
    });

    group.on("dragend", (e) => {
      const target = e.target;
      const position = target.getAbsolutePosition();

      const targetX = position.x;
      const targetY = position.y;

      if (targetX < sidebarX) {
        endCopyEnabled = true;
      } else {
        target.to({
          x: x,
          y: y,
          duration: 0.2, // Animation duration (in seconds) to snap back to original position
        });
      }

      if (endCopyEnabled && startCopyEnabled) {
        createCircle(sidebarX, boardY);
      }

      // reset Flags
      endCopyEnabled = false;
      startCopyEnabled = false;
    });

    deckLayer.add(group);
  };

  createCircle(sidebarX, boardY);

  function drawDeck() {
    // Reset Line
    line.points([boardX, boardY]);
    currentAngle = 0;

    try {
      const inputStr = (
        document.getElementById("inputData") as HTMLInputElement
      ).value;
      var values = inputStr.split(",").map((value) => value.trim());

      for (var i = 0; i < values.length; i += 2) {
        var angle = parseFloat(values[i]);
        var length = parseFloat(values[i + 1]);

        // Convert angle to Radians
        var angleRadians = ((currentAngle + angle) * Math.PI) / 180;

        // Calculate new endpoint coordinates
        var newX = boardX + length * Math.cos(angleRadians);
        var newY = boardY + length * Math.sin(angleRadians);

        line.points([...line.points(), newX, newY]);

        // Update current position and angle for the next segment
        boardX = newX;
        boardY = newY;
        currentAngle += angle;
      }

      line.draw();
    } catch (e) {
      alert(e);
    }
  }

  const button = document.getElementById("draw-button");
  button.addEventListener("click", (e) => {
    e.preventDefault();
    drawDeck();
  });
</script>

<style>
  canvas {
    border: 2px solid black;
  }
</style>

<div id="container" class="w-full h-full"></div>
